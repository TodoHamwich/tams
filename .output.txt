warning: in the working copy of 'scripts/tams.js', LF will be replaced by CRLF the next time Git touches it
diff --git a/scripts/tams.js b/scripts/tams.js
index 15000b2..835ea9b 100644
--- a/scripts/tams.js
+++ b/scripts/tams.js
@@ -1,11 +1,11 @@
-﻿/**
+/**
  * Data Models
  */
 class StatModifier extends foundry.abstract.DataModel {
   static defineSchema() {
     const fields = foundry.data.fields;
     return {
       value: new fields.NumberField({initial: 10, integer: true}),
       mod: new fields.NumberField({initial: 0, integer: true}),
       label: new fields.StringField()
     };
@@ -556,21 +556,63 @@ class TAMSAbilityData extends foundry.abstract.TypeDataModel {
   prepareDerivedData() {
     if (this.calculator?.enabled) {
       this.cost = this.calculatedCost;
     }
   }
 }

 /**
  * Documents
  */
-class TAMSActor extends Actor {}
+class TAMSActor extends Actor {
+  /** @override */
+  async _preUpdate(updateData, options, user) {
+    const res = await super._preUpdate(updateData, options, user);
+    if ( res === false ) return false;
+
+    // Check if endurance changed
+    const hasValue = foundry.utils.hasProperty(updateData, "system.stats.endurance.value");
+    const hasMod = foundry.utils.hasProperty(updateData, "system.stats.endurance.mod");
+
+    if (hasValue || hasMod) {
+      const stats = this.system.stats;
+      const oldVal = stats.endurance.value;
+      const oldMod = stats.endurance.mod;
+      const oldEnd = oldVal + (oldMod || 0);
+
+      const newVal = hasValue ? foundry.utils.getProperty(updateData, "system.stats.endurance.value") : oldVal;
+      const newMod = hasMod ? foundry.utils.getProperty(updateData, "system.stats.endurance.mod") : (oldMod || 0);
+      const newEnd = newVal + newMod;
+
+      if (newEnd !== oldEnd) {
+        const deltaEnd = newEnd - oldEnd;
+        const limbs = this.system.limbs;
+        for (const [key, limb] of Object.entries(limbs)) {
+          // Calculate the delta in max HP for this limb
+          const oldMax = Math.floor(oldEnd * limb.mult);
+          const newMax = Math.floor(newEnd * limb.mult);
+          const deltaMax = newMax - oldMax;
+
+          if (deltaMax !== 0) {
+            const currentPath = `system.limbs.${key}.value`;
+            const currentVal = foundry.utils.hasProperty(updateData, currentPath)
+                ? foundry.utils.getProperty(updateData, currentPath)
+                : limb.value;
+
+            foundry.utils.setProperty(updateData, currentPath, currentVal + deltaMax);
+          }
+        }
+      }
+    }
+    return res;
+  }
+}
 class TAMSItem extends Item {
   static get metadata() {
     return foundry.utils.mergeObject(super.metadata, {
       types: ["weapon", "skill", "ability", "equipment", "armor", "consumable", "tool", "questItem", "backpack"]
     }, {inplace: false});
   }
 }

 /**
  * Sheets
@@ -840,27 +882,33 @@ class TAMSActorSheet extends foundry.applications.api.HandlebarsApplicationMixin
     const item = dataset.itemId ? this.document.items.get(dataset.itemId) : null;

     // Resolve the first targeted token (if any)
     const tToken = [...(game?.user?.targets ?? [])][0] ?? null;
     const tName = tToken?.name ?? null;
     const tActorId = tToken?.actor?.id ?? null;
     const tTokenId = tToken?.id ?? null;

     let label = dataset.label || '';
     if (item && (item.type === 'weapon' || (item.type === 'ability' && item.system.isAttack))) {
-        if (tName) label = `${label} → ${tName}`;
+        if (tName) label = `${label} �� ${tName}`;
     }
     let statValue = parseInt(dataset.statValue) || 100;
     let statMod = parseInt(dataset.statMod) || 0;
     let familiarity = parseInt(dataset.familiarity) || 0;
     let statId = dataset.statId;

+    if (!item && statId === 'dodge') {
+        const dex = this.document.system.stats.dexterity;
+        statValue = dex.value;
+        statMod = dex.mod;
+    }
+
     if (!item) familiarity = 0; // Pure stat rolls don't include familiarity

     if (item && item.type === 'weapon') {
         const str = this.document.system.stats.strength;
         const dex = this.document.system.stats.dexterity;
         let usesDex = false;
         if (item.system.isRanged) {
             usesDex = !item.system.isThrown;
         } else {
             usesDex = !!item.system.isLight;
@@ -901,22 +949,83 @@ class TAMSActorSheet extends foundry.applications.api.HandlebarsApplicationMixin
             const stat = this.document.system.stats[statId];
             statValue = stat ? stat.value : 100;
             statMod = stat ? (stat.mod || 0) : 0;
             label = `Using Ability: ${item.name}`;
         } else {
             statId = item.system.capStat || "strength";
             const stat = this.document.system.stats[statId];
             statValue = stat ? stat.value : 100;
             statMod = stat ? (stat.mod || 0) : 0;
         }
-        const cost = parseInt(item.system.cost) || 0;
-        if (!item.system.isApex && cost > 0) {
+        const cost = item.system.calculator?.enabled ? item.system.calculatedCost : (parseInt(item.system.cost) || 0);
+        const usesMax = parseInt(item.system.uses.max) || 0;
+        const usesVal = parseInt(item.system.uses.value) || 0;
+        const isLimited = usesMax > 0;
+
+        if (event.shiftKey && isLimited) {
+            const missing = usesMax - usesVal;
+            const actor = this.document;
+            const resources = [{id: "stamina", name: "Stamina", value: actor.system.stamina.value}];
+            actor.system.customResources.forEach((res, idx) => {
+                resources.push({id: idx.toString(), name: res.name, value: res.value});
+            });
+            const resourceKey = item.system.resource;
+            const options = resources.map(r => `<option value="${r.id}" ${r.id === resourceKey ? 'selected' : ''}>${r.name} (${r.value} avail)</option>`).join('');
+
+            new Dialog({
+                title: `Refill ${item.name}`,
+                content: `
+                    <div class="form-group">
+                        <label>Amount to refill (Max ${missing})</label>
+                        <input type="number" id="refill-amount" value="${missing}" min="1" max="${missing}"/>
+                    </div>
+                    <div class="form-group">
+                        <label>Resource to spend</label>
+                        <select id="refill-resource">${options}</select>
+                    </div>
+                    <p>Cost per use: <b>${cost}</b></p>
+                    <p><i>Selecting an amount will multiply the cost.</i></p>
+                `,
+                buttons: {
+                    refill: {
+                        label: "Refill",
+                        callback: async (html) => {
+                            const amount = parseInt(html.find("#refill-amount").val()) || 0;
+                            const resId = html.find("#refill-resource").val();
+                            if (amount <= 0) return;
+                            const totalCost = amount * cost;
+                            const res = resources.find(r => r.id === resId);
+                            if (res.value < totalCost) return ui.notifications.warn("Not enough resource!");
+
+                            if (resId === 'stamina') {
+                                await actor.update({"system.stamina.value": res.value - totalCost});
+                            } else {
+                                const idx = parseInt(resId);
+                                const customResources = foundry.utils.duplicate(actor.system.customResources);
+                                customResources[idx].value -= totalCost;
+                                await actor.update({"system.customResources": customResources});
+                            }
+                            await item.update({"system.uses.value": usesVal + amount});
+                            ui.notifications.info(`Refilled ${amount} uses for ${item.name}.`);
+                        }
+                    },
+                    cancel: { label: "Cancel" }
+                },
+                default: "refill"
+            }).render(true);
+            return;
+        }
+
+        if (isLimited) {
+            if (usesVal <= 0) return ui.notifications.warn("No uses left! Shift-click to refill.");
+            await item.update({"system.uses.value": usesVal - 1});
+        } else if (!item.system.isApex && cost > 0) {
             const resourceKey = item.system.resource;
             if (resourceKey === 'stamina') {
                 const current = this.document.system.stamina.value;
                 if (current < cost) return ui.notifications.warn("Not enough Stamina!");
                 await this.document.update({"system.stamina.value": current - cost});
             } else {
                 const idx = parseInt(resourceKey);
                 const res = this.document.system.customResources[idx];
                 if (res) {
                     if (res.value < cost) {
@@ -1457,20 +1566,32 @@ Hooks.once("init", async function() {

   foundry.documents.collections.Actors.unregisterSheet("core", foundry.appv1.sheets.ActorSheet);
   foundry.documents.collections.Actors.registerSheet("tams", TAMSActorSheet, { makeDefault: true });
   foundry.documents.collections.Items.unregisterSheet("core", foundry.appv1.sheets.ItemSheet);
   foundry.documents.collections.Items.registerSheet("tams", TAMSItemSheet, { makeDefault: true });

   // Register Handlebars Helpers
   Handlebars.registerHelper('eq', function (a, b) {
     return a === b;
   });
+  Handlebars.registerHelper('gt', function (a, b) {
+    return a > b;
+  });
+  Handlebars.registerHelper('lt', function (a, b) {
+    return a < b;
+  });
+  Handlebars.registerHelper('gte', function (a, b) {
+    return a >= b;
+  });
+  Handlebars.registerHelper('lte', function (a, b) {
+    return a <= b;
+  });
   Handlebars.registerHelper('or', function (a, b) {
     return a || b;
   });
   Handlebars.registerHelper('and', function (a, b) {
     return a && b;
   });
   Handlebars.registerHelper('not', function (a) {
     return !a;
   });
   Handlebars.registerHelper('capitalize', function (str) {
@@ -1666,24 +1787,24 @@ Hooks.on("renderChatMessage", (message, html, data) => {
                           if (isAltArmor) {
                               const pending = updates[`system.limbs.${limbKey}.armorMax`];
                               const currentMax = pending !== undefined ? pending : (limb.armorMax || 0);
                               updates[`system.limbs.${limbKey}.armorMax`] = Math.max(0, currentMax - 1);
                           } else {
                               updates[`system.limbs.${limbKey}.armor`] = Math.max(0, armor - 1);
                           }
                       }
                       const lossLabel = isAltArmor ? "1 armor HP lost" : "1 armor point lost";
                       const penLabel = armourPen > 0 ? ` (Penetrated ${armourPen})` : "";
-                      report += `• ${loc}: ${effective} damage (${blocked} armor blocked${penLabel}, ${lossLabel})<br>`;
+                      report += `�E ${loc}: ${effective} damage (${blocked} armor blocked${penLabel}, ${lossLabel})<br>`;
                   } else {
                       const penLabel = armourPen > 0 ? ` (Penetrated ${armourPen})` : "";
-                      report += `• ${loc}: ${effective} damage (${blocked} armor blocked${penLabel})<br>`;
+                      report += `�E ${loc}: ${effective} damage (${blocked} armor blocked${penLabel})<br>`;
                   }

                   // Rule 2: Below -Max -> Automatic Injured
                   if (newHp <= -limb.max) {
                       updates[`system.limbs.${limbKey}.injured`] = true;
                   }
               }

               // Apply all updates atomically
               const finalUpdates = { ...updates };
@@ -1876,21 +1997,21 @@ Hooks.on("renderChatMessage", (message, html, data) => {
           `;
           if (!critInfo) critInfo = `<div class="tams-failure">Dodge Failed vs Total ${attackerTotal}</div>`;
       } else {
           // Defender wins normally
           hitsScored = 0;
           if (!critInfo) critInfo = `<div class="tams-success">Dodge Success vs Total ${attackerTotal}</div>`;
       }

       const msg = `
         <div class="tams-roll" data-attacker-raw="${attackerRaw}" data-attacker-total="${attackerTotal}" data-attacker-multi="${attackerMulti}" data-attacker-damage="${attackerDamage}" data-attacker-armour-pen="${attackerArmourPen}" data-actor-id="${actor.id}" data-raw="${raw}" data-capped="${capped}" data-behind="${isBehind ? '1' : '0'}" data-unaware="${isUnaware ? '1' : '0'}" data-first-location="${firstLocation}" data-is-ranged="${isRanged ? '1' : '0'}" data-target-limb="${targetLimb}">
-          <h3 class="roll-label">Dodge — ${actor.name} ${isBehind ? '(Behind)' : ''} ${isUnaware ? '(Unaware)' : ''}</h3>
+          <h3 class="roll-label">Dodge �X ${actor.name} ${isBehind ? '(Behind)' : ''} ${isUnaware ? '(Unaware)' : ''}</h3>
           <div class="roll-row"><span>Raw Dice Result:</span><span class="roll-value">${raw}</span></div>
           <div class="roll-row"><small>Stat Cap (Dex ${dexVal}):</small><span>${capped}</span></div>
           <div class="roll-boost-container"></div>
           <hr>
           <div class="roll-total">Total: <b>${total}</b></div>
           <div class="roll-hits-info">${damageInfo}</div>
           <div class="roll-crit-info">${critInfo}</div>
           <div class="roll-contest-hint">
             <small><b>Contest:</b> Total vs Attacker Total (${attackerTotal})</small><br>
             <small><b>Crit Check:</b> Raw vs Attacker Raw (${attackerRaw})</small>
@@ -2308,21 +2429,21 @@ Hooks.on("renderChatMessage", (message, html, data) => {
           <button class="tams-behind-toggle" style="background: #444; color: white;">Behind</button>
           <button class="tams-unaware-toggle" style="background: #444; color: white;">Unaware</button>
       ` : "");

       const retDescriptionHtml = (weapon.type === 'ability' && weapon.system.description)
         ? `<div class="roll-description">${weapon.system.description}</div>`
         : "";

       const msg = `
         <div class="tams-roll" data-attacker-raw="${raw}" data-attacker-total="${total}" data-attacker-multi="${multiVal}" data-armour-pen="${armourPen}" data-is-ranged="${isRanged ? '1' : '0'}" data-target-limb="${defenderTargetLimb}" data-orig-attacker-raw="${attackerRaw}" data-orig-attacker-total="${attackerTotal}" data-orig-attacker-multi="${attackerMulti}" data-orig-attacker-damage="${attackerDamage}" data-orig-attacker-armour-pen="${attackerArmourPen}" data-orig-first-location="${firstLocation}" data-orig-target-limb="${attackerTargetLimb}">
-          <h3 class="roll-label">Retaliation — ${actor.name} with ${weapon.name} ${isBehind ? '(Behind)' : ''} ${isUnaware ? '(Unaware)' : ''}</h3>
+          <h3 class="roll-label">Retaliation �X ${actor.name} with ${weapon.name} ${isBehind ? '(Behind)' : ''} ${isUnaware ? '(Unaware)' : ''}</h3>
           ${retDescriptionHtml}

           ${defenseDamageInfo}
           <hr>

           <div class="roll-row"><b>Damage: ${damage}</b></div>
           <div class="roll-row"><b>Hits Scored: ${hitsScored} / ${multiVal}</b></div>
           <div class="roll-row"><b>Hit Location: ${retLocations.length > 0 ? retLocations[0] : "-"}</b></div>
           ${retLocations.length > 1 ? `<div class="roll-row"><small>Additional Hits: ${retLocations.slice(1).join(", ")}</small></div>` : ""}
           <div class="roll-row"><b>Max Hits: ${multiVal}</b></div>